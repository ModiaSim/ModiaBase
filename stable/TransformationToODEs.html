<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transformation to ODE System · ModiaBase</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModiaBase</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="Tutorial.html">Tutorial</a></li><li><a class="tocitem" href="DataStructures.html">Data Structures</a></li><li><a class="tocitem" href="EquationSorting.html">Equation Sorting</a></li><li><a class="tocitem" href="EquationReduction.html">Equation Reduction</a></li><li class="is-active"><a class="tocitem" href="TransformationToODEs.html">Transformation to ODE System</a><ul class="internal"><li><a class="tocitem" href="#Main-Functions"><span>Main Functions</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="TransformationToODEs.html">Transformation to ODE System</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="TransformationToODEs.html">Transformation to ODE System</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ModiaSim/ModiaBase.jl/blob/master/docs/src/TransformationToODEs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Transformation-to-ODE-System"><a class="docs-heading-anchor" href="#Transformation-to-ODE-System">Transformation to ODE System</a><a id="Transformation-to-ODE-System-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-to-ODE-System" title="Permalink"></a></h1><p>This section provides functions to <strong>transform DAE to ODE systems</strong>. In particular,</p><ul><li>to find equations that need to be differentiated, in order to transform a Differential Algebraic Equations (DAEs) agebraically to Ordinary Differential Equations (ODEs),</li></ul><ul><li>to differentiate relevant equations analytically,</li></ul><ul><li>to statically select ODE states and transform to ODE form.</li></ul><h2 id="Main-Functions"><a class="docs-heading-anchor" href="#Main-Functions">Main Functions</a><a id="Main-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.BLTandPantelides.pantelides!" href="#ModiaBase.BLTandPantelides.pantelides!"><code>ModiaBase.BLTandPantelides.pantelides!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function pantelides!(G, M, A)</code></pre><p>Perform index reduction with Pantelides algorithm.</p><ul><li><code>G</code>: bipartite graph (updated)</li><li><code>M</code>: number of V-nodes</li><li><code>A</code>: A[j] = if V[k] = der(V[j]) then k else 0</li><li><code>return assign</code>: assign[j] contains the E-node to which V-node j is assigned or 0 if V-node j not assigned</li><li><code>return A</code>: A[j] = if V[k] = der(V[j]) then k else 0</li><li><code>return B</code>: B[i] = if E[l] = der(E[i]) then l else 0</li></ul><p>Reference: Pantelides, C.: The consistent initialization of differential-algebraic systems. SIAM Journal of Scientific and Statistical Computing, 9(2), pp. 213–231 (1988). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/BLTandPantelides.jl#L128-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.Differentiate.derivative" href="#ModiaBase.Differentiate.derivative"><code>ModiaBase.Differentiate.derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">der = derivative(ex, timeInvariants=[])</code></pre><p>Form the derivative of the expressions <code>ex</code> with regards to time. Time derivative of variables are denoted <code>der(v)</code>.</p><ul><li><code>ex</code>: Expression to differentiate</li><li><code>timeInvariants</code>: Vector of time invariant variables, i.e. with time derivative equal to zero.</li><li><code>return</code>der`: Time derivative of ex </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/Differentiate.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.StateSelectionFunctions" href="#ModiaBase.StateSelectionFunctions"><code>ModiaBase.StateSelectionFunctions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">stateSelectionFunctions = StateSelection.StateSelectionFunctions(;
    var_name               = v          -&gt; nothing,
    var_julia_name         = v          -&gt; nothing,
    var_unit               = v          -&gt; &quot;&quot;,
    var_startInitFixed     = v          -&gt; (nothing,false),   # (startOrInit, fixed)
    var_is_state           = v_original -&gt; false,
    equation               = e          -&gt; &quot;&quot;
    isSolvableEquation     = (e_original,v_original) -&gt; false,
    isLinearEquation       = (e_original,v_original) -&gt; (false, false),
    getSolvedEquationAST   = (e, v)                  -&gt; nothing,
    getResidualEquationAST = (e, residualName)       -&gt; nothing,
    showMessage            = (message; severity=0,from=&quot;???&quot;,details=&quot;&quot;,variables=Int[],equations=Int[]) -&gt; println(&quot;...&quot;)
)</code></pre><p>Generate an instance of an immutable struct that holds the callback functions as needed by <a href="TransformationToODEs.html#ModiaBase.getSortedAndSolvedAST"><code>getSortedAndSolvedAST</code></a>.</p><p>The functions need to have the following arguments:</p><ul><li><p><code>var_name(v::Int)::String</code>:<br/> Return full (Modia) path name of <code>v</code> as String (e.g. <code>&quot;a.b.c&quot;</code> or <code>&quot;a.b.der(c)&quot;</code>).</p></li><li><p><code>var_julia_name(v::Int)::String</code>:<br/>Return full Julia path name of variable <code>v</code> as <code>Symbol</code> (e.g. Symbol(&quot;m.a.b.c&quot;) or Symbol(&quot;a<em>b</em>der_c&quot;)).</p></li><li><p><code>var_unit(v::Int)::String</code>:<br/>Return unit of variable <code>v</code> as <code>String</code> (for example &quot;N*m&quot;) or <code>&quot;&quot;</code>, if no unit is defined.</p></li><li><p><code>var_startInitFixed(v::Int)::Tuple(Any,Bool)</code>:<br/>Return <code>(startOrInit, fixed)</code>, where <code>startOrInit</code> is the <code>start</code> or <code>init</code> value or <code>nothing</code> (if neither <code>start</code> nor <code>init</code> defined) and <code>fixed</code> is <code>true</code>, if an <code>init</code> value is defined.  </p></li><li><p><code>var_is_state(v_original::Int)::Bool</code>:<br/> Return true, if variable <code>v_original</code> is defined to be a state.</p></li><li><p><code>equation(e::Int)</code>:<br/> Return equation as string or &quot;&quot;, if equation is not provided.</p></li><li><p><code>isSolvableEquation(e_original::Int, v_original::Int)::Bool</code>:<br/> Return <code>true</code> if original, undifferentiated equation <code>e_original</code>  can be uniquely solved for variable <code>v_original</code>.</p></li><li><p><code>(isLinear, hasConstantCoefficient) = isLinearEquation(e_original::Int, v_original::Int)</code>:<br/> Return the information whether the original, undifferentiated equation <code>e</code>  is <strong>linear</strong> with respect to variable <code>v</code> (<code>isLinear=true</code>) and if this is the case whether  the coefficient of this linear term is <strong>constant</strong> after initialization  (<code>hasConstantCoefficient=true</code>). If <code>v</code> is an array, then the array equation <code>e</code> must  be linear with respect to all elements of array <code>v</code> in order to return <code>isLinear=true</code>.</p></li><li><p><code>AST = getSolvedEquationAST(e:Int, v:Int)</code>:<br/>Return Abstract Syntax Tree <code>AST::Expr</code> of equation <code>e</code> solved for variable <code>v</code> as instance of <code>Expr</code>.</p></li><li><p><code>AST = getResidualEquationAST(e::Int, residualName::Symbol)</code>:<br/>Return Abstract Syntax Tree <code>AST::Expr</code> of eqation <code>e</code> as residual equation with ustrip(..) <br/><code>residualName = ustrip( &lt; residual form of equation e&gt; )</code></p></li><li><p><code>showMessage(message; severity=0,from=&quot;???&quot;,details=&quot;&quot;,variables=Int[],equations=Int[])</code>:<br/>Print information, warning or error message.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/StateSelection.jl#L42-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.getSortedAndSolvedAST" href="#ModiaBase.getSortedAndSolvedAST"><code>ModiaBase.getSortedAndSolvedAST</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(success, AST, equationInfo) = getSortedAndSolvedAST(
                                    G, BLT, assign, A, B, stateSelectionFunctions;
                                    log = false, logDetails=false, modelName = &quot;???&quot;,
                                    defaultParameterAndStartValues = nothing,
                                    unitless=false)</code></pre><p>From the BLT on highest derivative level <code>(G, BLT, assign, A, B)</code>, a set of callback functions <code>stateSelectionFunctions</code>, this function returns the AST (Abstract Syntax Tree) of the sorted and solved equations as a vector of <code>Expr</code> and information about the ODE equations (especially names of the ODE states).</p><p><strong>Input arguments</strong></p><ul><li><p><code>G</code>: G[i] is the Integer vector of variable indices of equation i.  A variable i can be a scalar or an array.  is of type Vector{ Vector{Int} } or Vector{ Any }.</p></li><li><p><code>BLT::Vector{Vector{Int}}</code>: BLT[i] is the vector of equations belonging to BLT-block i. In principal, <strong>BLT[i] must include only highest derivative equations</strong>. In order to ease the generation of BLT[i], to not be forced to map indices forth and back when calling the function that computes the BLT, the following assumption is made: If BLT[j] contains only <strong>one equation with B[j][1] &gt; 0</strong> then this BLT block is a lower-derivative (dummy) block and is ignored.</p></li><li><p><code>assign::Vector{Int}</code>: ei = assign[vi] is equation ei assigned to variable vi</p></li><li><p><code>A</code>: A-Vector of Pantelides algorithm:      <code>A[i] = if der(v[i]) == v[k] then k else 0</code>      where <code>v[i]</code> is variable <code>i</code>.</p></li><li><p><code>B</code>: B-Vector of Pantelides algorithm:      <code>B[i] = if der(e[i]) == e[k] then k else 0</code>      where <code>e[i]</code> is equation <code>i</code>.</p></li><li><p><code>stateSelectionFunctions</code>: An instance of immutable struct <a href="TransformationToODEs.html#ModiaBase.StateSelectionFunctions"><code>StateSelectionFunctions</code></a> that holds the information about the callback functions needed by <code>getSortedAndSolvedAST</code>.</p></li><li><p><code>log</code>: = true: Print debug information (to find bugs in the code).</p></li><li><p><code>logDetails</code>: = true: Print detailed debug information, if <code>log = true</code>.</p></li><li><p><code>modelName</code>: Name of model used in messages (otherwise not used).</p></li></ul><p><strong>Output arguments</strong></p><p>A tuple with the following values:</p><ul><li><p><code>success::Bool</code>: = true, if generation was successful. = false, if an error occured. Arguments <code>AST, equationInfo</code> hold the information that have been collected until the error was detected.</p></li><li><p><code>AST::Vector{Expr}</code>: The AST (Abstract Syntax Tree) of the sorted and solved equations as Vector of <code>Expr</code>.</p></li><li><p><code>equationInfo::</code><a href="TransformationToODEs.html#ModiaBase.EquationInfo"><code>ModiaBase.EquationInfo</code></a>: Object that defines the states of the ODE.</p></li></ul><p>When variable <code>v</code> has neither a <code>start</code> nor <code>init</code> attribute defined, it is assumed to have <code>start=0.0</code>.</p><table><tr><th style="text-align: left">defined</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>start</code></td><td style="text-align: left"><code>start</code> is allowed to be changed during initialization</td></tr><tr><td style="text-align: left"><code>init</code></td><td style="text-align: left"><code>init</code> is not allowed to be changed during initialization</td></tr></table><p>Note, <code>start, init</code> influence the state selection.</p><p>If an ODE state has neither a <code>start</code> nor an <code>init</code> value defined, a warning message is printed (start/init value missing).</p><p>If a solved variable has an <code>init</code> value, an information message is printed in case <code>log=true</code> (init value has no effect).</p><p><strong>Sketch of the Algorithm</strong></p><p>Note, a statement <em>error xxx</em> means that an error occurs, because it is not possible to transform the equations to an ODE.</p><p><strong>Generate equation sets</strong></p><p>From BLT blocks that are not further differentiated (= highest order BLT blocks), generate the equation sets as described by the dummy derivative method of <a href="https://ieeexplore.ieee.org/document/274429">Mattsson and Söderlind (1992)</a>. See also sections 4.5 and 4.6 of the paper <a href="https://modelica.org/events/modelica2017/proceedings/html/submissions/ecp17132565_OtterElmqvist.pdf">Otter and Elmqvist (2017)</a>.</p><p><strong>Define initial ODE states</strong></p><p>Initially, all differentiated variables are defined to be ODE states. Whenever an initial ODE state is explicitly solved for in the course of the algorithm, the variable is no longer an ODE state.</p><p><strong>Analyse equation sets</strong></p><p>For every equation set on every differentiation level perform the following actions:</p><ul><li><p>If the equation set consists of <em>one</em> equation in <em>one</em> unknown, the equation is solved for this unknown (<em>error, if this is not possible</em>).</p></li><li><p>If the equation set consists of <em>N linear</em> equations in <em>N</em> unknowns solve this equation system (<em>error, if no linear system</em>):<br/>The equations are first teared to reduce the number of iteration variables and afterwards the teared equation system is solved with a special iterator loop that solves a linear equation system with an LU decomposition with column pivoting (for details see <a href="TransformationToODEs.html#ModiaBase.LinearEquationsIteration!"><code>ModiaBase.LinearEquationsIteration!</code></a>).<br/></p></li><li><p>If the equation set consists of <em>N linear</em> equations in <em>M</em> unknowns (<em>M &gt; N</em>) perform the following actions (<em>error, if no linear system</em>).<br/>Note, due to the structure of BLT, this equation set cannot be on highest derivative level; due to the Pantelides algorithm, M &lt; N is not possible).</p><ol><li><p>Solve the equation system explicitly via tearing for N unknowns (<em>error, if this is not possible</em>). Use start/init attributes of the M unknowns to influence tearing (e.g. it is tried to eliminate first variables that have neither start not init values).</p></li><li><p>The N solved variables have been initially ODE states and are now defined to be no ODE states (so called dummy states, that is algebraic variables).</p></li></ol></li></ul><p>A BLT transformation of <strong>all equations</strong> is made under the assumption that the selected ODE states are known. This phase is needed, because the dummy-derivative ordering at the beginning does not necessarily provide already the right ordering. In this phase the information from the previous phase is used (that is the already determined tearing variables for systems of equations are utilized).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/StateSelection.jl#L1093-L1228">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.StateCategory" href="#ModiaBase.StateCategory"><code>ModiaBase.StateCategory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum StateCategory</code></pre><p>Type of a state.</p><table><tr><th style="text-align: left">value</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><code>XD</code></td><td style="text-align: left">Differential variable (derivative of variable appears in equations)</td></tr><tr><td style="text-align: left"><code>XALG</code></td><td style="text-align: left">Algebraic variable that is included in x</td></tr><tr><td style="text-align: left"><code>XLAMBDA</code></td><td style="text-align: left">Algebraic variable that is included in der_x</td></tr><tr><td style="text-align: left"><code>XMUE</code></td><td style="text-align: left">Algebraic variable used for stabilization and included in der_x (exact value = 0)</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/EquationAndStateInfo.jl#L55-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.ResidualCategory" href="#ModiaBase.ResidualCategory"><code>ModiaBase.ResidualCategory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum ResidualCategory</code></pre><p>Type of a residual (see also <a href="TransformationToODEs.html#ModiaBase.StateCategory"><code>StateCategory</code></a> for the type of a state).</p><table><tr><th style="text-align: left">value</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><code>FD</code></td><td style="text-align: left">Differential equation (depends on XD, XLAMBDA, XMUE variables)</td></tr><tr><td style="text-align: left"><code>FC_ALG</code></td><td style="text-align: left">Constraint equation that is purely algebraic (depends on XALG variables)</td></tr><tr><td style="text-align: left"><code>FC_LOW_HIGH</code></td><td style="text-align: left">Constraint equation on lowest and on highest derivative level</td></tr><tr><td style="text-align: left"><code>FC_MUE</code></td><td style="text-align: left">Constraint equation that is associated with a stabilizer XMUE</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/EquationAndStateInfo.jl#L70-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.LinearEquations" href="#ModiaBase.LinearEquations"><code>ModiaBase.LinearEquations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">leq = LinearEquations{FloatType}(x_names::Vector{String}, x_vec_julia_names::AbstractVector,
                                 x_lengths::Vector{Int}, nx_fixedLength::Int, A_is_constant::Bool;
                                 useRecursiveFactorizationUptoSize = 0)</code></pre><p>Define linear equation system &quot;A*x=b&quot; with <code>x::Vector{FloatType}</code>.</p><ul><li><p><code>x</code> is constructed from a set of scalar or vector variables i with names <code>x_names[i]</code>  and length <code>x_length[i]</code> (that is <code>length(x) = sum(x_lengths)</code>). x<em>names[1:nx</em>fixedLength] are elements with fixed lengths (dimensions do not change after compilation). x<em>names[nx</em>fixedLength+1:end] are vector-valued elements where the dimensions may changer after compilation.</p></li><li><p><code>x_vec_julia_names</code> are the Julia names of the vector-valued elements.</p></li><li><p>If <code>A_is_constant = true</code> then <code>A</code> is a matrix that is constant after initialization</p></li><li><p>If length(x) &lt;= useRecursiveFactorizationUptoSize, then linear equation systems will be solved with <code>RecursiveFactorization.jl</code> instead of the default <code>lu!(..)</code> and <code>ldiv!(..)</code>.</p></li></ul><p>For details how to use this constructor, see <a href="TransformationToODEs.html#ModiaBase.LinearEquationsIteration!"><code>LinearEquationsIteration!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/EquationAndStateInfo.jl#L88-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.LinearEquationsIteration!" href="#ModiaBase.LinearEquationsIteration!"><code>ModiaBase.LinearEquationsIteration!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> iterating = LinearEquationsIteration!(leq, isInitial, [solve, isStoreResult,] time, timer)</code></pre><p>This function solves a linear equation system in residual form &quot;residual = A*x - b&quot; by iterating with a while loop over this system (arguments <code>solve, isStoreResult</code> are optional and have only an effect if leq.odeMode=false, that is if the linear equation system is solved in DAE mode):</p><pre><code class="language-julia hljs">function getDerivatives!(_der_x, _x, _m, _time)::Nothing
    _leq::Union{Nothing,LinearEquations{FloatType}} = nothing
    ...
    _leq      = _m.linearEquations[&lt;nr&gt;]   # leq::LinearEquations{FloatType}
    _leq.mode = -3  # initializes the iteration
    while LinearEquationsIteration!(_leq, _m.isInitial, _m.solve_leq, _m.storeResult, _m.time, _m.timer)
        x1 = _leq.x[1]
        x2 = _leq.x[2]
        x3 = _leq.x_vec[1]
        ...
        v_solved1 = f(x1, x2, ..., positive(x1,.., _leq))
        v_solved2 = f(x1, x2, ..., v_solved1)
        ...
        appendResidual!(_leq.residuals, &lt; getResiduals(x1,x2,...) &gt; )
    end
    ...
end</code></pre><p>Note, A and b can be functions of linear event operators, such as <code>positive(c_i&#39;*x - d_i)</code>. In this case this system is solved by a fixed point iteration scheme, that is <code>A*x = b</code> is solved until potentially present <code>positive(c_i&#39;*x - d_i)</code> calls are consistent to x (<code>c_i&#39;*x - d_i</code> and positive(..) must have the same sign). Iteration is terminated after 20 iterations if no convergence is found. In this case a warning message is triggered and simulation is continued (it might be that simulation is still successful, even if <code>x</code> and <code>positive(..)</code> are temporarily not consistent to each other).</p><p>The current values of A,x,b,residuals are stored in leq. If A is fixed after initialization (leq.A<em>is</em>constant = true), then A is computed only once at initialization, the LU decomposition of A is stored in leq and used in subsequent calls to solve the equation system.</p><p><strong>Input arguments</strong></p><ul><li><code>leq::LinearEquations{FloatType}</code>: Instance of <code>LinearEquations</code>.</li><li><code>isInitial::Bool</code>: = true: Called during initialization.</li><li><code>solve::Bool</code>: = true: leq.x is computed by LinearEquationsIteration!.                = false: leq.x has been set by calling environment                         (typically when called from DAE integrator).                         Note, at events and at terminate, solve must be true).</li><li><code>isStoreResult::Bool</code>: = true: Called at a communication point (store results).</li><li><code>time</code>: Actual time instant (only used for warning/error messages).</li><li><code>timer::TimerOutputs.TimerOutput</code>: Timer used to measure the solution of the linear equation system.</li></ul><p><strong>Output arguments</strong></p><ul><li>iterating::Bool: = true : Continue iteration of while-loop.                  = false: Immediately break while-loop after this function was terminated.</li></ul><p><strong>Enhancing efficiency</strong></p><p>Variable <code>leq.mode::Int</code> can be accessed (read-only) in the body of the while-loop to enhance efficiency. For example, if residuals are computed in a function and the function evaluation is expensive.</p><pre><code class="nohighlight hljs">leq.mode = -2: Residuals might be computed, but they are not used.
leq.mode = -1: Compute &quot;residuals .= A*x - b&quot;
leq.mode =  0: Compute &quot;residuals .= A*0 - b&quot;
leq.mode &gt;  0: Compute &quot;residuals .= A*e_i - b&quot;   # e_i = unit vector with i = leq.mode</code></pre><p><strong>Hidden argument <code>leq.mode::Int</code> on input</strong></p><pre><code class="language-julia hljs">leq.mode = -3  # LinearEquationsIteration! is called the first time
               if leq.odeMode || solve
                  # ODE mode or DAE mode at an event (solve &quot;x&quot; from equation &quot;residuals = A*x - b&quot;)
                  # Initialize fixed point iteration or continue fixed point iteration (if in DAE mode)
                  leq.niter     = 0      # Number of event iterations
                  leq.success   = false  # Event iteration was not yet successful
                  leq.x        .= 0
                  leq.mode      = 0      # Compute &quot;residuals .= A*0 - b&quot;
               else # solve = false
                  # DAE mode (but not at an event)
                  leq.niter     = 0
                  leq.success   = true
                  leq.x_is_zero = false
                  if isStoreResult
                     leq.mode = -2  # Residuals might be computed, but they are not used.
                  else
                     leq.mode = -1  # Compute &quot;residuals .= A*x - b&quot;
                  end
               end
               return true  # Continue while-loop

leq.mode = -2  # Terminate while-loop or initialize next event iteration
               if leq.success           # Set from leq.mode=-2 or leq.mode&gt;=0 or from event operators, such as positive!(...)
                  return false          # Terminate while-loop
               elseif leq.niter &gt; 20
                  &lt;warning&gt;             # Event iteration failed (variables are not consistent)
                  return false          # Terminate while-loop
               else
                  # Initialize next event iteration
                  leq.x        .= 0
                  leq.x_is_zero = true
                  leq.mode      = 0     # Compute &quot;residuals .= A*0 - b&quot;
                  return true           # Continue while-loop
               end

leq.mode = -1: @assert(!leq.odeMode &amp;&amp; !solve)
               # DAE mode, but not at an event
               return false      # Terminate while-loop

leq.mode =  0: @assert(leq.odeMode || solve)
               # ODE mode or DAE mode at an event (solve &quot;x&quot; from equation &quot;residuals = A*x - b&quot;)
               leq.b    = -leq.residuals
               leq.x[1] = 1.0
               leq.mode = 1      # Compute &quot;residuals := A*e_1 - b&quot;
               return true       # Continue while-loop

leq.mode &gt;  0: @assert(leq.odeMode || solve)
               j          = leq.mode
               leq.A[:,j] = leq.residuals + leq.b
               leq.x[j]   = 0.0
               if j &lt; nx
                   leq.x[j+1] = 1.0
                   leq.mode   = j+1      # Compute A[:,j+1] after the next iteration
                   return true           # Continue while-loop
               elseif j == nx
                   leq.x = solve(leq.A,leq.b) # Solve linear equation system A*x = b for x.
                   leq.mode    = -1      # Compute all variables IN the next iteration as function of x
                   leq.niter  += 1       # Increment number of iterations to solve A*x = b
                   leq.success = true    # Terminate for-loop at the beginning of the next iteration,
                                         # provided no positive(..) call changes its value.
                                         # (leq.success is set to false in positive(..), if the return value changes).
                   return true           # Continue while-loop
               end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/EquationAndStateInfo.jl#L205-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.EquationInfo" href="#ModiaBase.EquationInfo"><code>ModiaBase.EquationInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">eqInfo = EquationInfo(;
            status               = MANUAL,
            ode                  = true,
            nz                   = 0,
            x_info               = StateElementInfo[],
            nx                   = -1,
            nxFixedLength        = nx,
            residualCategories   = ResidualCategory[],
            linearEquations      = Tuple{Vector{String},AbstractVector,Vector{Int},Int,Bool}[],
            vSolvedWithFixedTrue = String[],
            defaultParameterAndStartValues = nothing,
            ResultType = nothing,
            ResultTypeHasFloatType = false)</code></pre><p>Return instance <code>eqInfo</code> that defines the information for the equation system.</p><p><strong>Arguments</strong></p><ul><li>status::EquationInfoStatus: Defines the variables that have a value.</li><li>ode: = true if ODE-interface (<code>getDerivatives!</code>),      = false if DAE-interface (<code>getResiduals!</code>).</li><li>nz: Number of zero crossing functions.</li><li>x_info: Vector of StateElementInfo elements provding info for every x-element</li><li>residualCategories: If ode=true, length(residualCategories) = 0.            If ode=false: residualCategories[i] is the <code>ResidualCategory</code>](@ref) of x-element &quot;i&quot;.</li><li><code>linearEquations::Vector{Tuple{Vector{String},AbstractVector,Vector{Int},Int,Bool}}</code>:              linearEquations[i] defines a              ModiaBase.LinearEquations system, where the first tuple value              is a vector of the names of the unknowns,              the second tuple value is a vector of the Julia names of the vector-valued elements,              the third tuple value is a vector with the lengths of the unknowns,              the fourth tuple value is the number of residuals and the fifth tuple value              defines whether the coefficient matrix A              has only constant entries (=true) or not (=false).</li><li><code>vSolvedWithFixedTrue::Vector{String}</code>: Vector of variables that are computed              from other variables and have <code>fixed=true</code>. During initialization              it is checked whether the calculated values and the start values of              these variables agree. If this is not the case, an error is triggered.</li><li><code>defaultParameterAndStartValues</code>: Dictionary of default paramter and default start values.</li><li><code>ResultType::AbstractModelValues</code>: ModelValues type that shall be used for the result generation              (= ModelValues struct without parameters).</li><li><code>ResultTypeHasFloatType::Bool</code>: = false, if <code>ResultType</code> is not parameterized.                                 = true, if <code>ResultType</code> has parameter <code>FloatType</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/EquationAndStateInfo.jl#L680-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.StateElementInfo" href="#ModiaBase.StateElementInfo"><code>ModiaBase.StateElementInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">xe_info = StateElementInfo(...)</code></pre><p>Return an instance of the mutable struct <code>StateElementInfo</code> that defines the information for one element of the state vector. There are three constructors:</p><ul><li><p>Default constructor (all variables under section Arguments are given; used to write/read the complete information).</p></li><li><p>All variables under section Arguments are given with exception of startIndex (used for <code>EquationInfoStatus = CODE_GENERATION</code>).</p></li><li><p>StateElementInfo(x<em>name, der</em>x_name, stateCategory; fixed=nothing, nominal=NaN, unbounded=false) (used for <code>EquationInfoStatus = MANUAL</code>):</p></li></ul><p><strong>Arguments</strong></p><ul><li>x_name: Name of x-element or &quot;&quot; if no name (if stateCatebory = XLAMBDA or XMUE)</li><li>x<em>name</em>julia: Julia name of x-element in getDerivatives!/getResiduals! function or &quot;&quot; if not needed (since no code generation).</li><li>der<em>x</em>name: Name of der<em>x-element or &quot;&quot; if either `der(x</em>name)` or if no name (if stateCategory = XALG).</li><li>der<em>x</em>name<em>julia: Julia name of der</em>x-element in getDerivatives!/getResiduals! function or &quot;&quot; if not needed (since no code generation).</li><li>stateCategory::StateCategory: Category of the state</li><li>length: length of x-element (or -1 if not yet known)</li><li>unit: unit of XD, XALG (x<em>name) or XLAMBDA, XMUE (der</em>x_name) or &quot;&quot; if not yet known)</li><li>fixed: false (= guess value) or true (= not changed by initialization).        Only relevant for ode=false, otherwise ignored.</li><li>nominal: Nominal value (NaN if determined via start value)</li><li>unbounded: false or true</li><li>startIndex: start index of x-element with respect to x-vector             or -1 if not yet known.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/EquationAndStateInfo.jl#L539-L571">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="EquationReduction.html">« Equation Reduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Sunday 20 February 2022 22:20">Sunday 20 February 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
