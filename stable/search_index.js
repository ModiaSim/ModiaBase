var documenterSearchIndex = {"docs":
[{"location":"EquationSorting.html#Equation-Sorting","page":"Equation Sorting","title":"Equation Sorting","text":"","category":"section"},{"location":"EquationSorting.html","page":"Equation Sorting","title":"Equation Sorting","text":"This section provides functions to sort systems of equations.","category":"page"},{"location":"EquationSorting.html#Main-Functions","page":"Equation Sorting","title":"Main Functions","text":"","category":"section"},{"location":"EquationSorting.html","page":"Equation Sorting","title":"Equation Sorting","text":"CurrentModule = ModiaBase.BLTandPantelides","category":"page"},{"location":"EquationSorting.html","page":"Equation Sorting","title":"Equation Sorting","text":"matching\r\nBLT","category":"page"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelides.matching","page":"Equation Sorting","title":"ModiaBase.BLTandPantelides.matching","text":"function matching(G, M, vActive=fill(true, M))\n\nFind maximum matching in bipartite graph\n\nG: bipartite graph\nM: number of V-nodes\nvActive: set to false has the same effect as deleting V-node and corresponding edges\nreturn assign: assign[j] contains the E-node to which V-node j is assigned or 0 if V-node j not assigned\n\nReference: Pantelides, C.: The consistent initialization of differential-algebraic systems. SIAM Journal of Scientific and Statistical Computing, 9(2), pp. 213â€“231 (1988). \n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelides.BLT","page":"Equation Sorting","title":"ModiaBase.BLTandPantelides.BLT","text":"function BLT(G, assign)\n\nFind Block Lower Triangular structure for a bipartite graph G with assignment assign\n\nG: bipartite graph\nassign: assign[j] contains the E-node to which V-node j is assigned or 0 if V-node j not assigned\nreturn components: cell array of components. Each component is a list of indices to E-nodes\n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#Utility-Functions","page":"Equation Sorting","title":"Utility Functions","text":"","category":"section"},{"location":"EquationSorting.html","page":"Equation Sorting","title":"Equation Sorting","text":"CurrentModule = ModiaBase.BLTandPantelidesUtilities","category":"page"},{"location":"EquationSorting.html","page":"Equation Sorting","title":"Equation Sorting","text":"invertDer\r\ninvertAssign\r\nbuildExtendedSystem\r\nbuildFullIncidence\r\ncreateNames\r\nprintList\r\nprintAssignedEquations\r\nprintSortedEquations\r\nprintUnassigned","category":"page"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.invertDer","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.invertDer","text":"function invertDer(A)\n\nInvert derivative relationships for variables and equations\n\nA: A[j] = if V[k] = der(V[j]) then k else 0 (or correspondingly for E-nodes)\nreturn orgIndex: index of original variable or equation\nreturn derOrder: derivative order\n\nNote that invertDer can be used to invert from list of E-nodes to list of V-nodes as well.\n\nExample:  julia> BLTandPantelidesUtilities.invertDer([5,6,7,8,10,11,0,0,0,0,0]) ([1,2,3,4,1,2,3,4,9,1,2],[0,0,0,0,1,1,1,1,0,2,2])\n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.invertAssign","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.invertAssign","text":"invertAssign(assign, n=length(assign))\n\nInvert assignment relationships for variables and equations.\n\nassign: assign[j] contains the E-node to which V-node j is assigned or 0 if V-node j not assigned\nn: number of E-nodes\nreturn invAssign: invAssign[i] contains the V-node to which E-node i is assigned or 0 if E-node i not assigned\nreturn unAssigned: unassigned V-nodes\n\nNote that invertAssign can be used to invert from list of E-nodes to list of V-nodes as well.\n\nExample: julia> inv=BLTandPantelidesUtilities.invertAssign([0,0,0,0,1,2,7,4,3,9,8]) ([5,6,9,8,0,0,7,11,10,0,0],[1,2,3,4])\n\njulia> BLTandPantelides.invertAssign(inv[1]) ([0,0,0,0,1,2,7,4,3,9,8],[5,6,10,11])\n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.buildExtendedSystem","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.buildExtendedSystem","text":"function buildExtendedSystem(A)\n\nExtend a system according to Pantelides equation (15), i.e. return the incidence for function h(x, der(x)).\n\nA: A[j] = if V[k] = der(V[j]) then k else 0\nreturn G: bipartite graph\n\nExample:        julia> BLTandPantelidesUtilities.buildExtendedSystem([5,6,7,8,0,0,0,0,0])     4-element Array{Any,1}:      [1,5]      [2,6]      [3,7]      [4,8]\n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.buildFullIncidence","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.buildFullIncidence","text":"buildFullIncidence(n,m)\n\nBuild a bipartite graph with full incidence, i.e. all of the n E-nodes refer to all of the m V-nodes.\n\nn: number of E-nodes\nm: number of V-nodes\nreturn G: bipartite graph\n\nExample:      julia> BLTandPantelidesUtilities.buildFullIncidence(2,3)      2-element Array{Any,1}:       [1,2,3]       [1,2,3] \n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.createNames","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.createNames","text":"function createNames(infixes, A)\n\nCreates names.\n\ninfixes: infix strings for original variable \nA: A[j] = if V[k] = der(V[j]) then k else 0 \n\nExample: julia> BLTandPantelidesUtilities.createNames([\"x\", \"y\", \"w\", \"z\", \"\", \"\", \"\", \"\", \"T\"], [5,6,7,8,10,11,0,0,0,0,0]) x, y, w, z, der(x), der(y), der(w), der(z), T, der2(x), der2(y)\n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.printList","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.printList","text":"function printList(infixes, indices, A, vertical=false)\n\nPrint list of variables or equations.\n\ninfixes: infix strings for original variable or equation\nindices: indices for the variables or equations to be printed\nA: A[j] = if V[k] = der(V[j]) then k else 0 (or correspondingly for E-nodes)\nvertical: if vertical then new line separation else comma separation\n\nExample: julia> BLTandPantelidesUtilities.printList([\"x\", \"y\", \"w\", \"z\", \"\", \"\", \"\", \"\", \"T\"], 1:11, [5,6,7,8,10,11,0,0,0,0,0]) x, y, w, z, der(x), der(y), der(w), der(z), T, der2(x), der2(y)\n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.printAssignedEquations","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.printAssignedEquations","text":"printAssignedEquations(equations, variables, indices, assign, A, B)\n\nPrint assigned equations.\n\nequations: infix string for original equations\nvariables: infix string for original variables\nindices: indices for the equations to be printed\nassign: assign[j] contains the E-node to which V-node j is assigned or 0 if V-node j not assigned\nA: A[j] = if V[k] = der(V[j]) then k else 0\nB: B[i] = if E[l] = der(E[l]) then l else 0\n\nExample: See testBLTandPantelides.testPendulum\n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.printSortedEquations","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.printSortedEquations","text":"printSortedEquations(equations, variables, components, assign, A, B)\n\nPrint sorted equations.\n\nequations: infix string for original equations\nvariables: infix string for original variables\ncomponents: cell array of components. Each component is a list of indices to E-nodes\nassign: assign[j] contains the E-node to which V-node j is assigned or 0 if V-node j not assigned\nA: A[j] = if V[k] = der(V[j]) then k else 0\nB: B[i] = if E[l] = der(E[l]) then l else 0\n\nExample: See testBLTandPantelides.testPendulum\n\n\n\n\n\n","category":"function"},{"location":"EquationSorting.html#ModiaBase.BLTandPantelidesUtilities.printUnassigned","page":"Equation Sorting","title":"ModiaBase.BLTandPantelidesUtilities.printUnassigned","text":"printUnassigned(equations, variables, components, assign, A, B)\n\nPrint unassigned variables and equations.\n\nequations: infix string for original equations\nvariables: infix string for original variables\nassign: assign[j] contains the E-node to which V-node j is assigned or 0 if V-node j not assigned\nA: A[j] = if V[k] = der(V[j]) then k else 0\nB: B[i] = if E[l] = der(E[l]) then l else 0\n\nExample: See testBLTandPantelides.testPendulum\n\n\n\n\n\n","category":"function"},{"location":"Tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"This chapter contains a short tutorial about the data structures and functions provided by package ModiaBase.","category":"page"},{"location":"Tutorial.html#.-Regular-DAEs-(Index-Zero-DAEs)","page":"Tutorial","title":"1. Regular DAEs (Index Zero DAEs)","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"In this subsection functions are demonstrated that can be used to transform regular DAEs to ODEs.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"The transformations are explained with the following simple electrical circuit (a low pass filter where the voltage source is modelled with an inner resistor):","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: Low Pass Filter)","category":"page"},{"location":"Tutorial.html#.1-Bi-Partite-Graph","page":"Tutorial","title":"1.1 Bi-Partite Graph","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"In a first step, the structural information of the low pass filter model is provided as incidence matrix","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: Incidence Matrix of Low Pass Filter)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Every column corresponds to one time-varying variable. Parameters, so variables with constant values, are not shown.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Every row corresponds to one equation.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"A cell is marked (here in blue), if a time-varying variable is present in one equation. Variables that are appearing differentiated, such as C.v, are not marked because in a first analysis phase, these potential state variables are treated as known.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"The matrix above is called the incidence matrix or the bi-partite graph of the circuit. In ModiaBase, this matrix is represented as vector G of Integer vectors:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Bi-partite graph of low pass filter\r\nG = [ [25,27],  # equation 1 depends on variables 25,27\r\n      [6,23],\r\n      [4,10],\r\n      ...,\r\n      [27] ]","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"This can be also made more explicit (and a bit more efficient storage) by defining the incidence matrix as:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Bi-partite graph of low pass filter\r\nG = Vector{Int}[ [25,27],  # equation 1 depends on variables 25,27\r\n                 [6,23],\r\n                 [4,10],\r\n                 ...,\r\n                 [27] ]","category":"page"},{"location":"Tutorial.html#.2-Linear-Integer-Equations","page":"Tutorial","title":"1.2 Linear Integer Equations","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Object-oriented models consist of a lot of linear Integer equations, especially due to the connect-statements. The linear integer equations of G are identified and the corresponding linear factors are determined. With function simplifyLinearIntegerEquations! this information is used to simplify the equations by transforming the linear Integer equations with a fraction-free (exact) Gaussian elimination to a special normalized form and then perform the following simplifications:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Equations of the form v = 0 are removed and v is replaced by â€ž0â€œ at all places where v occurs, and these equations are simplified.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Equations of the form v1 = v2 and v1 = -v2 are removed, v1  is replaced by v2 (or -v2) at all places where v1 occurs (so called alias-variables), and these equations are simplified.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Redundant equations are removed.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Variables that appear only in the linear Integer equations (and in no other equations) are set to zero, if they can be arbitrarily selected. For example, if an electrical circuit is not grounded, then one of the electrical potentials is arbitrarily set to zero.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"State constraints are made structurally visible.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"After applying simplifyLinearIntegerEquations! to the low pass filter circuit, the incidence matrix is simplified to","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: Incidence Matrix of Low Pass Filter)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Bi-partite graph of simplified low pass filter\r\nG = Vector{Int}[ [1,2,4],\r\n                 [1,7],\r\n                 [3,4],\r\n                 [3,7],\r\n                 [6,7],\r\n                 [2] ]\r\n\r\n# Eliminated variables\r\nR.i        = -(V.p.i)\r\nground.p.v = 0\r\nR.p.i      = -(V.p.i)\r\nR.n.v      = C.v\r\nV.n.i      = -(V.p.i)\r\nV.n.v      = 0\r\nV.p.v      = Ri.n.v\r\nRi.p.i     = V.p.i\r\nC.n.v      = 0\r\nC.p.v      = C.v\r\nRi.p.v     = R.p.v\r\nC.n.i      = V.p.i\r\nV.i        = V.p.i\r\nR.n.i      = V.p.i\r\nC.p.i      = -(V.p.i)\r\nground.p.i = 0\r\nC.i        = -(V.p.i)\r\nRi.i       = V.p.i\r\nV.v        = Ri.n.v\r\nRi.n.i     = -(V.p.i)","category":"page"},{"location":"Tutorial.html#.3-Assignment","page":"Tutorial","title":"1.3 Assignment","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"In a follow-up step, an assignment is made (also called matching), to associate one variable uniquely with one equation:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: Matched IIncidence Matrix of Low Pass Filter)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Red marks show the assigned variables.\nBlue marks show if a variable is part of the respective equation","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"The assignment is computed with function ModiaBase.matching returning a vector assign:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"using ModiaBase\r\nvActive    = fill(true,7)\r\nvActive[5] = false    # state C.v is known\r\nassign     = matching(G, 7, vActive)\r\n\r\n# assign = [2,6,3,1,0,5,4]","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"The meaning of vector assign is that","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Variable 1 is solved from equation 2,\nVariable 2 is solved from equation 6,\netc.","category":"page"},{"location":"Tutorial.html#.4-Sorting","page":"Tutorial","title":"1.4 Sorting","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"In a follow-up step, equations are sorted and algebraic loops determined (= Block Lower Triangular transformation):","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: Incidence Matrix of sorted equations of Low Pass Filter)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Red marks show the assigned variables.\nBlue marks show if a variable is part of the respective equation\nA grey area marks an algebraic loop.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"The sorting is computed with function ModiaBase.BLT:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"using ModiaBase\r\nblt = BLT(G, assign)\r\n\r\n#=\r\n    blt = [ [6],\r\n            [3,4,2,1],\r\n            [5] ]\r\n=#","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"The meaning is for example that the second BLT block consists of equations 3,4,2,1 and these equations form an algebraic loop.","category":"page"},{"location":"Tutorial.html#.5-Reducing-sizes-of-equation-systems","page":"Tutorial","title":"1.5 Reducing sizes of equation systems","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"In a follow-up step, the sizes of equation systems are reduced by variable substitution (= tearing). Applying ModiaBase.tearEquations! to the  low pass filter circuit, reduces the dimension of BLT block 2 from size 4 to size 1 resulting in the following equation system:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"# iteration variables (inputs): C.i\r\n# residual variables (outputs): residual\r\n\r\nR.v := R.R*C.i\r\nR.i.v := -Ri.R*C.i\r\nR.p.v := Ri.v + V.v\r\nresidual := R.v - R.p.v + C.v","category":"page"},{"location":"Tutorial.html#.6-Generation-of-AST","page":"Tutorial","title":"1.6 Generation of AST","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"In a final step, the AST (Abstract Syntax Tree) of the model is generated. Hereby, it is determined that the equation system of section 1.4 and 1.5 is linear in the iteration variable (C.i) and an AST is generated to build-up a linear equation system A*C.i = b and solve this system numerically with an LU decomposition whenever the AST is called (if the equation system has size 1,  a simple division is used instead of calling a linear equation solver). Applying Modia.getSortedAndSolvedAST results basically in a function getDerivatives that can be solved with the many ODE integrators of DifferentialEquations.jl:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"function getDerivatives(_der_x, _x, _m, _time)::Nothing\r\n    _m.time = ModiaLang.getValue(_time)\r\n    _m.nGetDerivatives += 1\r\n    instantiatedModel = _m\r\n    _p = _m.evaluatedParameters\r\n    _leq_mode = nothing\r\n    time = _time\r\n    var\"C.v\" = _x[1]\r\n    var\"V.v\" = (_p[:V])[:V]\r\n    begin\r\n        local var\"C.i\", var\"R.v\", var\"Ri.v\", var\"R.p.v\"\r\n        _leq_mode = _m.linearEquations[1]\r\n        _leq_mode.mode = -2\r\n        while ModiaBase.LinearEquationsIteration!(_leq_mode, _m.isInitial, _m.time, _m.timer)\r\n            var\"C.i\" = _leq_mode.vTear_value[1]\r\n            var\"R.v\" = (_p[:R])[:R] * var\"C.i\"\r\n            var\"Ri.v\" = (_p[:Ri])[:R] * -var\"C.i\"\r\n            var\"R.p.v\" = var\"Ri.v\" + var\"V.v\"\r\n            _leq_mode.residual_value[1] = (var\"R.v\" + -1var\"R.p.v\") + var\"C.v\"\r\n        end\r\n        _leq_mode = nothing\r\n    end\r\n    var\"der(C.v)\" = var\"C.i\" / (_p[:C])[:C]\r\n    _der_x[1] = var\"der(C.v)\"\r\n    if _m.storeResult\r\n        ModiaLang.addToResult!(_m, _der_x, time, var\"R.v\", var\"R.p.v\", var\"Ri.v\", var\"C.i\", var\"V.v\")\r\n    end\r\n    return nothing\r\nend","category":"page"},{"location":"Tutorial.html#.-Singular-DAEs-(Higher-Index-DAEs)","page":"Tutorial","title":"2. Singular DAEs (Higher Index DAEs)","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"xxx","category":"page"},{"location":"EquationReduction.html#Equation-Reduction","page":"Equation Reduction","title":"Equation Reduction","text":"","category":"section"},{"location":"EquationReduction.html","page":"Equation Reduction","title":"Equation Reduction","text":"This section provides functions to reduce the dimensions of systems of equations.","category":"page"},{"location":"EquationReduction.html#Linear-Integer-Equations","page":"Equation Reduction","title":"Linear Integer Equations","text":"","category":"section"},{"location":"EquationReduction.html","page":"Equation Reduction","title":"Equation Reduction","text":"Many equations of object-oriented models are linear Integer equations (such as all equations deduced from connections, or, say defining a potential difference) and can be pre-processed exactly to simplify the equations, for example elimination of alias variables, or variables that are identically to zero). Furthermore, (consistently) redundant or (consistently) overdetermined equations can be removed. Finally, hidden state constraints can be made explicit in order that a structural algorithm (such as the algorithm of Pantelides) can process state constraints.","category":"page"},{"location":"EquationReduction.html","page":"Equation Reduction","title":"Equation Reduction","text":"CurrentModule = ModiaBase","category":"page"},{"location":"EquationReduction.html","page":"Equation Reduction","title":"Equation Reduction","text":"simplifyLinearIntegerEquations!\r\nprintSimplifiedLinearIntegerEquations","category":"page"},{"location":"EquationReduction.html#ModiaBase.simplifyLinearIntegerEquations!","page":"Equation Reduction","title":"ModiaBase.simplifyLinearIntegerEquations!","text":"(vEliminated, vProperty, nvArbitrary, redundantEquations) = \n    simplifyLinearIntegerEquations!(G, eInt, GcInt, Avar)\n\nRemove singularities of the linear Integer equations of a DAE system and simplify these equations as much as possible. \n\nThe following singularities are fixed by this function:\n\nEquations that are redundant are removed.\nState constraint that are not structurally visible are transformed to a structurally visible form so that structural index reduction algorithms, such as the Pantelides algorithm, can handle these state constraints.\nVariables that can have an arbitrary value and do not appear in the remaining set of equations (so must be solved from the linear Integer equations) are set to zero. The calling function should print a warning message in such a case (if nvArbitrary > 0).\n\nThe following simplifications are performed recursively (c is an arbitrary Integer literal):\n\nAn equation c*v1 = 0 is removed and v1 is replaced by zero in all occurrences of the linear Integer equations and all expressions with v1 are simplified.\nAn equation c*v2 + c*v3 = 0 or c*v2 - c*v3 = 0 is removed and v2 is replaced by v3 or by -v3 in all occurrences of the linear Integer equations and all expressions with v2 and v3 are simplified.\n\nNote:\n\nInput arguments G, eInt, GcInt are changed by a call of this function and represent the transformed linear Integer equations. The Abstract Syntax Tree (AST) of all these equations must be  replaced by new AST equations defined by the returned arguments.\nThe number of operations in the transformed linear Integer equations is  guaranteed to be not larger as the original equations - with exception of the structurally visible state constraints, where the number of operations could be larger.\nPotential states (variables appearing differentiated) and derivatives of potential states are not eliminated by this function.\n\nInput arguments\n\nG: Bi-partite graph/incidence matrix of all equations. Typically: G::Vector{Vector{Int}}      On entry, G is the original graph. On exit, the linear Integer equations of G are      typically changed.\neInt::Vector{Int}: G[eInt] are the linear Integer equations of G.      On exit, eInt is reordered. If length(G[eInt[i]]) = 0, then the corresponding equation is eliminated.\nGcInt: GcInt[i] is the vector of Integer coefficients that are associated with the variables           of G[eInt[i]]. Typically: GcInt::Vector{Vector{Int}}.          On exit, GcInt is reordered according to eInt and typically most of the coefficients have been changed.\nAvar::Vector{Int}: Defines the derivatives of the variables:          A[i] = if der(v_i) == v_k then k else 0. This vector is not changed by simplifyLinearIntegerEquations!.\n\nOutput arguments\n\nvEliminated::Vector{Int}: Variables that are eliminated.\nvProperty::Vector{Int}:  Defines the properties of the eliminated variables. These properties can be inquired with the following exported functions:\no isNotEliminated(vProperty, v) - if variable v is not eliminated. o isEliminated(vProperty, v) - if variable v is eliminated. o isZero(vProperty,v) - if eliminated variable v is zero. o isAlias(vProperty,v) - if eliminated variable v is an alias variable v = valias o isNegAlias(vProperty,v) - if eliminated variable v is a negative alias variable v = -valias o alias(vProperty,v) - alias variable valias of eliminated variable v (v = valias). o negAlias(vProperty,v) - negated alias variable valias of eliminated variable v (v = -valias).\nnvArbitrary::Int: Variables vEliminated[1:nvArbitrary] are variables that can be arbitrarily set and that             have been set to zero.\nredundantEquations::Vector{Int}: G[redundantEquations] are redundant equations that have been removed.\n\nAlgorithm\n\nThe algorithm to remove the singularities is sketched in the paper:\n\nOtter, Elmqvist (2017): Transformation of Differential Algebraic Array Equations to Index One Form, section 5. Modelica'2017 Conference.\n\nAn error in this algorithm was fixed, the algorithm was improved to handle large equation systems and to simplify equations as much as possible.      \n\nMain developer\n\nMartin Otter,  DLR - Institute of System Dynamics and Control\n\n\n\n\n\n","category":"function"},{"location":"EquationReduction.html#ModiaBase.printSimplifiedLinearIntegerEquations","page":"Equation Reduction","title":"ModiaBase.printSimplifiedLinearIntegerEquations","text":"printSimplifiedLinearIntegerEquations(G, eInt, GcInt, vEliminated, vProperty, \n    nvArbitrary, redundantEquations, var_name::Function; printTest=false)\n\nPrint result of simplifyLinearIntegerEquations!. \n\nFunction var_name(v) returns the name of variable v as String.\n\nIf printTest=true, statements are printed that can be included in a Testset.\n\n\n\n\n\n","category":"function"},{"location":"EquationReduction.html#Algebraic-Systems","page":"Equation Reduction","title":"Algebraic Systems","text":"","category":"section"},{"location":"EquationReduction.html","page":"Equation Reduction","title":"Equation Reduction","text":"Algebraic equation systems are reduced by selecting a subset of the variables as iteration variables and computing the remaining variables in a forward sequence.","category":"page"},{"location":"EquationReduction.html","page":"Equation Reduction","title":"Equation Reduction","text":"CurrentModule = ModiaBase","category":"page"},{"location":"EquationReduction.html","page":"Equation Reduction","title":"Equation Reduction","text":"TearingSetup\r\ntearEquations!","category":"page"},{"location":"EquationReduction.html#ModiaBase.TearingSetup","page":"Equation Reduction","title":"ModiaBase.TearingSetup","text":"ts = TearingSetup(G [,nv])\n\nGenerate a setup object ts from a bi-partite graph G  to reduce one or more systems of equations that are present in G.  The returned object ts holds internal auxiliary storage that is used in analysis with function tearEquations!. \n\nG is expected to be a vector of integer vectors  (for example of type Vector{ Vector{Int} }). The optional argument nv is the largest integer number occuring in G (= number of variables). If nv is not provided, it is deduced from G. \n\nTearingSetup is useful to reduce the amount of memory to be allocated,  if function tearEquations! shall be called several times on equation systems from G.\n\n\n\n\n\n","category":"type"},{"location":"EquationReduction.html#ModiaBase.tearEquations!","page":"Equation Reduction","title":"ModiaBase.tearEquations!","text":"(eSolved, vSolved, eResidue, vTear) = tearEquations!(GorTs, isSolvable, es, vs; \n    eSolvedFixed=Int[], vSolvedFixed=Int[], check=true)\n\nThis function tears a system of equations consisting of equations es and eSolvedFixed that are functions of variables vs and vSolvedFixed. The optional arguments eSolvedFixed, vSolvedFixed  define the starting Directed Acyclic Graph (solving equations eSolvedFixed[1] for variable vSolvedFixed[1], eSolvedFixed[2] for variable vSolvedFixed[2] etc.) starting at vSolvedFixed[1].\n\nThe function returns the teared equations so that if vTear are given, vSolved can be computed from eSolved in a forward sequence (so solving eSolved[1] for vSolved[1], eSolved[2] for vSolved[2], and so on). vTear must be selected, so that the equations eResidues are fulfilled. Equations eSolved and eResidue are the (reordered) union of es and eSolvedFixed. Variables vSolvedandvTearare the (reordered) union ofvsandvSolvedFixed`.\n\nThis means that an algebraic equation system 0 = g(w)  (g are equations es and eSolvedFixed;  w are unknowns vs and vSolvedFixed) is solved as  much as possible explicitly for the unknowns resulting in\n\nw_e := g_e(w_t)\n  0  = g_r(w_t, w_e)\n\nwhere \n\nw (= vs and vSolvedFixed) consists of all elements of w_e, w_t;\nequations g_e of g are explicitly solved for w_e;\nequations g_r are the equations of g that cannot be explicitly solved (= residual equations).\n\nRequired arguments\n\nGorTs: Either a bi-partite graph G::Vector{Vector{Int}} or ts::TearingSetup          generated with constructor ts = TearingSetup(G).                  ts is re-initialized in tearEquations! for any call of the function.          TearingSetup is useful to reduce the amount of memory to be allocated,           if several equation systems shall be teared from G.\nisSolvable(e,v): Function that returns true, if equation e          can be solved for variable v without influencing the solution space          (= rank preserving operation).\nes::Vector{Int}: Vector of equations that shall be solved with respect to variables vs.          es must be equations from G.\nvs: Either of type Vector{Int} or of type Vector{Vector{Int}}.           vs are the unknown variables that shall be solved from es.           If vs::Vector{Vector{Int}}, it is first tried to solve es           for vs[1], then for vs[2] etc.           (so vs defines a priority to solve for variables).            \n\nOptional arguments\n\neSolvedFixed::Vector{Int}: Equations of G that are already defined to be solved for vSolvedFixed.\nvSolvedFixed::Vector{Int]: Variables of G that are explicitly solved from eSolvedFixed.\ncheck::Bool: = true, if various checks shall be performed, for example           that eSolvedFixed/vSolvedFixed and eSolved/vSolved are a DAG respectively.\n\nReturn arguments\n\neSolved::Vector{Int}: Equations that are explicitly solved in the order eSolved[1], eSolved[2], ....\nvSolved::Vector{Int}: Equation eSolved[i] is explicitly solved for variable vSolved[i].\neResdiue::Vector{Int}: Residual equations that are not explicitly solved.\nvTear::Vector{Int}: Tearing variables, so variables that are assumed to be known, when solving                       equations eSolved.\n\nExample\n\nusing ModiaBase\n\nG = Vector{Int}[ [1,2,4],  # equation 1 depends on variables 1,2,4\n                 [1,7],\n                 [3,4],\n                 [3,7],\n                 [6,7],\n                 [2] ]\n    \nes = [3,4,2,1]    # Solve equations 3,4,2,1                 \nvs = [3,7,1,4]    # for variables 3,7,1,4 \nisSolvable(e,v) = true  # Assume that every equation is solvable for its unknowns \n \n(eSolved,vSolved,eResidue,vTear) = tearEquations!(G, isSolvable, es, vs)\n\n# eSolved  = [3,4,2]\n# vSolved  = [3,7,1]\n# eResidue = [1]\n# vTear    = [4]\n\nAlgorithm\n\nThe algorithm used in this function is sketched in the paper:\n\nOtter, Elmqvist (2017): Transformation of Differential Algebraic Array Equations to Index One Form.  Modelica'2017 Conference.\n\nThe function uses several extensions of the described basic tearing algorithm that are important for transforming higher index Differential Algebraic Equations to index one form. Note, the traversals in Directed-Acyclic-Graphs - the core operation of the tearing algorithm - is not performed with recursive function calls but with  while loops and an explicit stack, in order to avoid function stack overflow for large algebraic loops. Tests up to 1 million equations in 1 million unknowns have been performed.\n\nFor improving efficiency, algorithm N of the following paper is used as utility algorithm:\n\nBender, Fineman, Gilbert, Tarjan (2016):  A New Approach to Incremental Cycle Detection and Related Problems. ACM Transactions on Algorithms, Volume 12, Issue 2, Feb.\n\nMain developer\n\nMartin Otter,  DLR - Institute of System Dynamics and Control\n\n\n\n\n\n","category":"function"},{"location":"DataStructures.html#Data-Structures","page":"Data Structures","title":"Data Structures","text":"","category":"section"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"In this chapter the basic data structures are summarized and shortly described that are used in package ModiaBase.","category":"page"},{"location":"DataStructures.html#.-Bi-partite-Graph","page":"Data Structures","title":"1. Bi-partite Graph","text":"","category":"section"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The bi-partite Graph G of a DAE system defines the functional dependency of the equations e_i from time-varying variables v_j. G is also a sparse representation of the incidence matrix of the DAE system. Example:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"# Bi-partite graph of low pass filter\r\nG = Vector{Int}[ [1,2,4], # equation 1 depends on variables 1,2,4\r\n                 [1,7],   # equation 2 depends on variables 1,7\r\n                 [3,4],\r\n                 [3,7],\r\n                 [6,7],\r\n                 [2] ]","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"In ModiaBase, only potential states and unknown variables are described with G. Dependency on parameters (= constant quantities) is not shown.","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The number of variables is usually larger as the number of equations, because both the potential states and their derivatives are stored in G.","category":"page"},{"location":"DataStructures.html#.-Assignment-Vector","page":"Data Structures","title":"2. Assignment Vector","text":"","category":"section"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The assignment vector assign defines for all equations and variables the unique variable v_j that is solved from equation e_i. Example:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"assign = [2,6,3,1,0,5,4]  # Variable 1 is solved from equation 2\r\n                          # Variable 2 is solved from equation 6\r\n                          #  ...\r\n                          # Variable 5 is not solved from any equation","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The inverted assignment vector invAssign defines the unique equation e_i that is solved for the unique variable v_j. This vector can be directly computed from vector assign. Example:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"(invAssign, unAssigned) = invertAssign(assign)\r\n\r\n# invAssign = [4,1,3,7,6,2,0]   # Equation 1 is solved for variable 4\r\n                                # Equation 2 is solved for variable 1\r\n                                # ...\r\n                                # Equation 7 is not solved for any variable","category":"page"},{"location":"DataStructures.html#.-Block-Lower-Triangular-Form","page":"Data Structures","title":"3. Block Lower Triangular Form","text":"","category":"section"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The Block Lower Triangular form blt of an equation system describes the sorted set of equations, in order to solve for the unknown variables. With vector invAssign (see subsection 2 above) the information is provided for which variable the respective equation is solved.","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"Example:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"blt = [ [6],        # Solve first equation 6\r\n        [3,4,2,1],  # Afterwards solve equations 3,4,2,1 (they form an algebraic loop)\r\n        [5] ]       # Finally solve equation 5\r\n\r\ninvAssign = [4, 1, 3, 7, 6, 2, 0]","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The meaning is:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"Equation 6 is solved for variable 2.\nEquations 3,4,2,1 are solved simultaneously for variables 3, 7, 1, 4.\nEquation 5 is solved for variable 6.","category":"page"},{"location":"DataStructures.html#.-Variable-Association-Vector","page":"Data Structures","title":"4. Variable Association Vector","text":"","category":"section"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The derivative relationship between variables is described with the variable association vector Avar and its inverted vector invAvar:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"beginaligned\r\n    Avar_j = left beginarrayrl\r\n                        k  texttextbfif dotv_j equiv v_k \r\n                        0  texttextbfif v_j text is not a differentiated variable\r\n                      endarrayright \r\n    invAvar_j = left beginarrayrl\r\n                            k  texttextbfif v_j equiv dotv_k \r\n                            0  texttextbfif v_j text is not a differentiated variable\r\n                         endarrayright\r\nendaligned","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"Example:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The following derivative relationships between variables v1,v2,v3,v4,v5","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"   1. v1\r\n   2. v2 = der(v1)\r\n   3. v3 = der(v2)\r\n   4. v4\r\n   5. v5 = der(v4)","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"are expressed by the following variable association vector and its inverted form:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"   Avar    = [2,3,0,5,0]   # The derivative of variable 1 is variable 2\r\n                           # The derivative of variable 2 is variable 3\r\n                           #  ...\r\n\r\n   invAvar = [0,1,2,0,4]   # Variable 1 is not a derivative\r\n                           # Variable 2 is the derivative of variable 1\r\n                           #   ...\r\n                           # Variable 5 is the derivative of variable 4","category":"page"},{"location":"DataStructures.html#.-Equation-Association-Vector","page":"Data Structures","title":"5. Equation Association Vector","text":"","category":"section"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The derivative relationship between equations is described with the equation association vector Bequ and its inverted vector invBequ:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"beginaligned\r\n    Bequ_i = left beginarrayrl\r\n                        k  texttextbfif dote_i equiv e_k \r\n                        0  texttextbfif dote_i text does not exist\r\n                      endarrayright \r\n    invBequ_i = left beginarrayrl\r\n                            k  texttextbfif e_i equiv dote_k \r\n                            0  texttextbfif _i text is not a differentiated equation\r\n                         endarrayright\r\nendaligned","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"Example:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"The following derivative relationships between equations e1,e2,e3,e4,e5","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"   1. e1\r\n   2. e2 = der(e1)\r\n   3. e3 = der(e2)\r\n   4. e4\r\n   5. e5 = der(e4)","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"are expressed by the following equation association vector and its inverted form:","category":"page"},{"location":"DataStructures.html","page":"Data Structures","title":"Data Structures","text":"   Bvar    = [2,3,0,5,0]   # The derivative of equation 1 is equation 2\r\n                           # The derivative of equation 2 is equation 3\r\n                           #  ...\r\n\r\n   invBvar = [0,1,2,0,4]   # Equation 1 is not a differentiated equation\r\n                           # Equation 2 is the derivative of equation 1\r\n                           #   ...\r\n                           # Equation 5 is the derivative of equation 4","category":"page"},{"location":"TransformationToODEs.html#Transformation-to-ODE-System","page":"Transformation to ODE System","title":"Transformation to ODE System","text":"","category":"section"},{"location":"TransformationToODEs.html","page":"Transformation to ODE System","title":"Transformation to ODE System","text":"This section provides utility functions to transform DAE to ODE systems. In particular,","category":"page"},{"location":"TransformationToODEs.html","page":"Transformation to ODE System","title":"Transformation to ODE System","text":"to find equations that need to be differentiated, in order to transform a Differential Algebraic Equations (DAEs) agebraically to Ordinary Differential Equations (ODEs),","category":"page"},{"location":"TransformationToODEs.html","page":"Transformation to ODE System","title":"Transformation to ODE System","text":"to differentiate relevant equations analytically,","category":"page"},{"location":"TransformationToODEs.html#Main-Functions","page":"Transformation to ODE System","title":"Main Functions","text":"","category":"section"},{"location":"TransformationToODEs.html","page":"Transformation to ODE System","title":"Transformation to ODE System","text":"CurrentModule = ModiaBase.BLTandPantelides","category":"page"},{"location":"TransformationToODEs.html","page":"Transformation to ODE System","title":"Transformation to ODE System","text":"pantelides!","category":"page"},{"location":"TransformationToODEs.html#ModiaBase.BLTandPantelides.pantelides!","page":"Transformation to ODE System","title":"ModiaBase.BLTandPantelides.pantelides!","text":"function pantelides!(G, M, A)\n\nPerform index reduction with Pantelides algorithm.\n\nG: bipartite graph (updated)\nM: number of V-nodes\nA: A[j] = if V[k] = der(V[j]) then k else 0\nreturn assign: assign[j] contains the E-node to which V-node j is assigned or 0 if V-node j not assigned\nreturn A: A[j] = if V[k] = der(V[j]) then k else 0\nreturn B: B[i] = if E[l] = der(E[i]) then l else 0\n\nReference: Pantelides, C.: The consistent initialization of differential-algebraic systems. SIAM Journal of Scientific and Statistical Computing, 9(2), pp. 213â€“231 (1988). \n\n\n\n\n\n","category":"function"},{"location":"TransformationToODEs.html","page":"Transformation to ODE System","title":"Transformation to ODE System","text":"CurrentModule = ModiaBase.Differentiate","category":"page"},{"location":"TransformationToODEs.html","page":"Transformation to ODE System","title":"Transformation to ODE System","text":"derivative","category":"page"},{"location":"TransformationToODEs.html#ModiaBase.Differentiate.derivative","page":"Transformation to ODE System","title":"ModiaBase.Differentiate.derivative","text":"der = derivative(ex, timeInvariants=[])\n\nForm the derivative of the expressions ex with regards to time. Time derivative of variables are denoted der(v).\n\nex: Expression to differentiate\ntimeInvariants: Vector of time invariant variables, i.e. with time derivative equal to zero.\nreturnder`: Time derivative of ex \n\n\n\n\n\n","category":"function"},{"location":"index.html#ModiaBase.jl-Documentation","page":"Home","title":"ModiaBase.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ModiaBase provides functions to support the transformation of a Differential Algebraic Equation system (DAE)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"0 = f_dae(fracdx_daedtx_daewt) tag1","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"to an explicit Ordinary Differential Equation system (ODE)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"beginaligned\r\n  fracdx_odedt = f_x(x_odet) \r\n         (w x_dae) = f_w(x_odet)\r\nendaligned tag2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"where x=x(t) w=w(t) are vector valued functions of the scalar variable t (= usually time). x_dae is the DAE state vector, x_ode is the ODE state vector - a subset of x_dae, and w are purely algebraic variables that do not appear differentiated in the DAE. The equations are hereby represented as a vector of Julia expressions, that is of an Abstract Syntax Tree (AST).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"These functions are used by package Modia, but can also be utilized in another context. Especially the following functionality is provided:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Simplify linear Integer equations (many equations of object-oriented models are linear Integer equations and can be pre-processed exactly)\nto remove alias variables and equations,\nto remove redundant equations,\nto provide definite values for variables that can have arbitrary values if this makes sense,\nto make state constraints structurally visible.\nFind a variable assignment of an equation system, in order to transform the equation system in a directed graph that can be further processed.\nFind the strong components in a directed graph (with the algorithm of Tarjan) to determine algebraic equation systems that must be solved together.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Sort an equation system (= transform to Block Lower Triangular form),  to determine the order in which the equations have to be evaluated.\nReduce the dimension of algebraic equation systems by tearing.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Find equations that need to be differentiated one or more times (with the algorithm of Pantelides) in order that the DAE can be transformed to an ODE.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Analytically differentiate the found equations.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Statically select ODE states and transform to ODE form (hereby identifying linear equation systems that must be solved during simulation).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Transformation from a DAE to an ODE form is (currently) performed if no nonlinear-algebraic equations appear and the ODE-states can be statically selected.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Array variables and array equations are kept (they are not \"flattened\" in single elements). However, DAE forms that require to differentiate array equations, are not yet supported.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The following extensions are planned (internal prototypes are available):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Full support of array equations.\nIf transformation to an ODE is not possible with the algorithms above, transformation to a special index 1 DAE, that can be simulated with standard DAE solvers (such as Sundials IDA).","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package is registered and is installed with (Julia 1.7 is required):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add ModiaBase","category":"page"},{"location":"index.html#Release-Notes","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Version-0.10.0","page":"Home","title":"Version 0.10.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Non-backwards compatible changes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"EquationAndStateInfo.jl and StateSelection.jl moved to Modia (ModiaLang is merged into Modia), because the AST generation in these files depends on details of CodeGeneration.jl of Modia/ModiaLang.\nTestLinearEquations.jl also moved to Modia/ModiaLang.","category":"page"},{"location":"index.html#Version-0.9.2","page":"Home","title":"Version 0.9.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Minor (efficiency) improvement of linear equation system if iteration variables are SVectors. ","category":"page"},{"location":"index.html#Version-0.9.1","page":"Home","title":"Version 0.9.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Update of Manifest.toml file","category":"page"},{"location":"index.html#Version-0.9.0","page":"Home","title":"Version 0.9.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Non-backwards compatible improvements","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Parameter values in the code are now type cast to the type of the parameter value from the  @instantiatedModel(..) call. The benefit is that access of parameter values in the code is type stable and operations with the parameter value are more efficient and at run-time no memory is allocated. Existing models can no longer be simulated, if parameter values provided via simulate!(.., merge=xx) are not type compatible to their definition. For example, an error is thrown if the @instantedModel(..) uses a Float64 value and the simulate!(.., merge=xx) uses a Measurement{Float64} value for the same parameter.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Other improvements","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Hierarchical names in function calls supported (e.g. a.b.c.fc(..)). ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Functions can return multiple values, e.g. (tau1,tau2) = generalizedForces(derw1, derw2).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Large speedup of symbolic transformation, if function depends on many input (and output) arguments  (includes new operator implicitDependency(..)).\nSupport for StaticArrays variables (the StaticArrays feature is kept in the generated AST).\nSupport for Array variables (especially of state and tearing variables) where the dimension can change after @instantiateModel(..)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Included DAE-Mode in solution of linear equation system (if DAE integrator is used and all unknowns of a linear equation system are part of the DAE states, solve the linear equation system during continuous integration via DAE solver (= usually large simulation speed-up, for larger linear equation systems)  ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Improved code generation of linear equation systems lead to more efficient solution of linear equation systems.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Bug fixes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Do no longer expand the unit macro in the AST, such as u\"N\", because otherwise logCode=true results in wrong code (previously, a u\"N\"  definition in the model was displayed in the code as N which is not correct Julia code).","category":"page"},{"location":"index.html#Version-0.8.1","page":"Home","title":"Version 0.8.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Update Project.toml, Manifest.toml, README.md","category":"page"},{"location":"index.html#Version-0.8.0","page":"Home","title":"Version 0.8.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Require Julia 1.7\nUpgrade Manifest.toml to version 2.0\nUpdate Project.toml/Manifest.toml","category":"page"},{"location":"index.html#Version-0.7.8","page":"Home","title":"Version 0.7.8","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tests of TestDifferentiate.jl corrected to comply with DiffRules > 1.0\nScaling introduced to improve numerics when constructing A-matrix of linear equation system.","category":"page"},{"location":"index.html#Version-0.7.7","page":"Home","title":"Version 0.7.7","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Bug fixed when selecting RecursiveFactorization.jl","category":"page"},{"location":"index.html#Version-0.7.6","page":"Home","title":"Version 0.7.6","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Fixed bug in StateSelection.jl: If unitless=true, no unit is associated with the tearing variable.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Solve linear equation systems optionally with RecursiveFactorization.jl  instead of the default lu!(..) and ldiv!(..).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Project.toml: Changed DiffRules from \"~1.0\" to \"1\", since issue with \"1.2.1\"  (leading to an error in runtests) seems to be fixed.\nProject.toml: Added version 1 of MonteCarloMeasurements.\nUpdated used packages.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Tutorial slightly improved.","category":"page"},{"location":"index.html#Version-0.7.5","page":"Home","title":"Version 0.7.5","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Added a restriction, so that DiffRules 1.0.2 is used, instead of 1.2.1 (which leads to an error in the test suite).","category":"page"},{"location":"index.html#Version-0.7.4","page":"Home","title":"Version 0.7.4","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"showCodeWithoutComments(code): Bug corrected to only remove comments and not other code (ModiaLang.@instantiateModel(..., logCode=true, ...) gave wrong output).\nUsed packages updated","category":"page"},{"location":"index.html#Version-0.7.3","page":"Home","title":"Version 0.7.3","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Speed improvements for structural and symbolic algorithms.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Added support for state events, time events and synchronous operators (positive(), Clock(), after(), pre(), previous(), hold(), initial(), terminal()) ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Added support for mixed linear equation systems having Real and Boolean unknowns.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Simplified code for linear equation systems (while-loop instead of for-loop).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Added TimerOutputs @timeit instrumentation to the solution of linear equation systems.","category":"page"},{"location":"index.html#Version-0.7.2","page":"Home","title":"Version 0.7.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Support of parameters as hierarchical named tuples.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Support of array comprehensions.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Support of array end (e.g. A[3:end])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If one equation cannot be solved for one unknown (e.g. since function call), try to solve it as linear equation system.\nIf variables with init values are explicitly solved for, print warning message only if log = true (in TinyModia.simulate! an error occurs, if the init value cannot be respected).","category":"page"},{"location":"index.html#Version-0.7.1","page":"Home","title":"Version 0.7.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Due to version conflicts, added version 0.17 of DataStructures in compat.","category":"page"},{"location":"index.html#Version-0.7.0","page":"Home","title":"Version 0.7.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Initial version, based on code developed for Modia 0.6 and ModiaMath 0.6.","category":"page"},{"location":"index.html#Main-developers","page":"Home","title":"Main developers","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Hilding Elmqvist, Mogram.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Martin Otter, DLR - Institute of System Dynamics and Control","category":"page"}]
}
