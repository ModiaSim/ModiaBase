<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Equation Reduction · ModiaBase</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModiaBase</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="Tutorial.html">Tutorial</a></li><li><a class="tocitem" href="DataStructures.html">Data Structures</a></li><li><a class="tocitem" href="EquationSorting.html">Equation Sorting</a></li><li class="is-active"><a class="tocitem" href="EquationReduction.html">Equation Reduction</a><ul class="internal"><li><a class="tocitem" href="#Linear-Integer-Equations"><span>Linear Integer Equations</span></a></li><li><a class="tocitem" href="#Algebraic-Systems"><span>Algebraic Systems</span></a></li></ul></li><li><a class="tocitem" href="TransformationToODEs.html">Transformation to ODE System</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="EquationReduction.html">Equation Reduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="EquationReduction.html">Equation Reduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ModiaSim/ModiaBase.jl/blob/master/docs/src/EquationReduction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Equation-Reduction"><a class="docs-heading-anchor" href="#Equation-Reduction">Equation Reduction</a><a id="Equation-Reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Equation-Reduction" title="Permalink"></a></h1><p>This section provides functions to <strong>reduce the dimensions of systems of equations</strong>.</p><h2 id="Linear-Integer-Equations"><a class="docs-heading-anchor" href="#Linear-Integer-Equations">Linear Integer Equations</a><a id="Linear-Integer-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Integer-Equations" title="Permalink"></a></h2><p>Many equations of object-oriented models are <strong>linear Integer equations</strong> (such as all equations deduced from connections, or, say defining a potential difference) and can be pre-processed exactly to simplify the equations, for example elimination of alias variables, or variables that are identically to zero). Furthermore, (consistently) redundant or (consistently) overdetermined equations can be removed. Finally, hidden state constraints can be made explicit in order that a structural algorithm (such as the algorithm of Pantelides) can process state constraints.</p><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.simplifyLinearIntegerEquations!" href="#ModiaBase.simplifyLinearIntegerEquations!"><code>ModiaBase.simplifyLinearIntegerEquations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(vEliminated, vProperty, nvArbitrary, redundantEquations) = 
    simplifyLinearIntegerEquations!(G, eInt, GcInt, Avar)</code></pre><p>Remove singularities of the <strong>linear Integer equations</strong> of a DAE system and simplify these equations as much as possible. </p><p>The following <strong>singularities</strong> are fixed by this function:</p><ul><li><p>Equations that are redundant are removed.</p></li><li><p>State constraint that are not structurally visible are transformed to a structurally visible form so that structural index reduction algorithms, such as the Pantelides algorithm, can handle these state constraints.</p></li><li><p>Variables that can have an arbitrary value and do not appear in the remaining set of equations (so must be solved from the linear Integer equations) are set to zero. The calling function should print a warning message in such a case (if <code>nvArbitrary &gt; 0</code>).</p></li></ul><p>The following <strong>simplifications</strong> are performed recursively (<code>c</code> is an arbitrary Integer literal):</p><ul><li>An equation <code>c*v1 = 0</code> is removed and <code>v1</code> is replaced by zero in all occurrences of the linear Integer equations and all expressions with <code>v1</code> are simplified.</li><li>An equation <code>c*v2 + c*v3 = 0</code> or <code>c*v2 - c*v3 = 0</code> is removed and <code>v2</code> is replaced by <code>v3</code> or by <code>-v3</code> in all occurrences of the linear Integer equations and all expressions with <code>v2</code> and <code>v3</code> are simplified.</li></ul><p>Note:</p><ul><li>Input arguments <code>G, eInt, GcInt</code> are changed by a call of this function and represent the transformed linear Integer equations. The Abstract Syntax Tree (AST) of all these equations must be  replaced by new AST equations defined by the returned arguments.</li><li>The number of operations in the transformed linear Integer equations is  guaranteed to be not larger as the original equations - with exception of the structurally visible state constraints, where the number of operations could be larger.</li><li>Potential states (variables appearing differentiated) and derivatives of potential states are <strong>not</strong> eliminated by this function.</li></ul><p><strong>Input arguments</strong></p><ul><li><p><code>G</code>: Bi-partite graph/incidence matrix of all equations. Typically: <code>G::Vector{Vector{Int}}</code>      On entry, <code>G</code> is the original graph. On exit, the linear Integer equations of <code>G</code> are      typically changed.</p></li><li><p><code>eInt::Vector{Int}</code>: <code>G[eInt]</code> are the linear Integer equations of <code>G</code>.      On exit, <code>eInt</code> is reordered. If <code>length(G[eInt[i]]) = 0</code>, then the corresponding equation is eliminated.</p></li><li><p><code>GcInt</code>: <code>GcInt[i]</code> is the vector of Integer coefficients that are associated with the variables           of <code>G[eInt[i]]</code>. Typically: <code>GcInt::Vector{Vector{Int}}</code>.          On exit, <code>GcInt</code> is reordered according to <code>eInt</code> and typically most of the coefficients have been changed.</p></li><li><p><code>Avar::Vector{Int}</code>: Defines the derivatives of the variables:          <code>A[i] = if der(v_i) == v_k then k else 0</code>. This vector is not changed by <code>simplifyLinearIntegerEquations!</code>.</p></li></ul><p><strong>Output arguments</strong></p><ul><li><p><code>vEliminated::Vector{Int}</code>: Variables that are eliminated.</p></li><li><p><code>vProperty::Vector{Int}</code>:  Defines the properties of the eliminated variables. These properties can be inquired with the following exported functions:</p><p>o <code>isNotEliminated(vProperty, v)</code> - if variable v is not eliminated. o <code>isEliminated(vProperty, v)</code> - if variable v is eliminated. o <code>isZero(vProperty,v)</code> - if eliminated variable v is zero. o <code>isAlias(vProperty,v)</code> - if eliminated variable v is an alias variable v = v<em>alias o <code>isNegAlias(vProperty,v)</code> - if eliminated variable v is a negative alias variable v = -v</em>alias o <code>alias(vProperty,v)</code> - alias variable v<em>alias of eliminated variable v (v = v</em>alias). o <code>negAlias(vProperty,v)</code> - negated alias variable v<em>alias of eliminated variable v (v = -v</em>alias).</p></li><li><p><code>nvArbitrary::Int</code>: Variables <code>vEliminated[1:nvArbitrary]</code> are variables that can be arbitrarily set and that             have been set to zero.</p></li><li><p><code>redundantEquations::Vector{Int}</code>: G[redundantEquations] are redundant equations that have been removed.</p></li></ul><p><strong>Algorithm</strong></p><p>The algorithm to remove the singularities is sketched in the paper:</p><ul><li>Otter, Elmqvist (2017): <a href="http://www.ep.liu.se/ecp/132/064/ecp17132565.pdf">Transformation of Differential Algebraic Array Equations to Index One Form</a>, section 5. Modelica&#39;2017 Conference.</li></ul><p>An error in this algorithm was fixed, the algorithm was improved to handle large equation systems and to simplify equations as much as possible.      </p><p><strong>Main developer</strong></p><p><a href="https://rmc.dlr.de/sr/en/staff/martin.otter/">Martin Otter</a>,  <a href="https://www.dlr.de/sr/en">DLR - Institute of System Dynamics and Control</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/LinearIntegerEquations.jl#L437-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.printSimplifiedLinearIntegerEquations" href="#ModiaBase.printSimplifiedLinearIntegerEquations"><code>ModiaBase.printSimplifiedLinearIntegerEquations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">printSimplifiedLinearIntegerEquations(G, eInt, GcInt, vEliminated, vProperty, 
    nvArbitrary, redundantEquations, var_name::Function; printTest=false)</code></pre><p>Print result of <a href="EquationReduction.html#ModiaBase.simplifyLinearIntegerEquations!"><code>simplifyLinearIntegerEquations!</code></a>. </p><p>Function <code>var_name(v)</code> returns the name of variable <code>v</code> as String.</p><p>If <code>printTest=true</code>, statements are printed that can be included in a Testset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/LinearIntegerEquations.jl#L701-L710">source</a></section></article><h2 id="Algebraic-Systems"><a class="docs-heading-anchor" href="#Algebraic-Systems">Algebraic Systems</a><a id="Algebraic-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-Systems" title="Permalink"></a></h2><p><strong>Algebraic equation systems</strong> are reduced by selecting a subset of the variables as iteration variables and computing the remaining variables in a forward sequence.</p><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.TearingSetup" href="#ModiaBase.TearingSetup"><code>ModiaBase.TearingSetup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ts = TearingSetup(G [,nv])</code></pre><p>Generate a setup object <code>ts</code> from a bi-partite graph <code>G</code>  to reduce one or more systems of equations that are present in <code>G</code>.  The returned object <code>ts</code> holds internal auxiliary storage that is used in analysis with function <a href="EquationReduction.html#ModiaBase.tearEquations!"><code>tearEquations!</code></a>. </p><p><code>G</code> is expected to be a vector of integer vectors  (for example of type <code>Vector{ Vector{Int} }</code>). The optional argument <code>nv</code> is the largest integer number occuring in <code>G</code> (= number of variables). If <code>nv</code> is not provided, it is deduced from <code>G</code>. </p><p><code>TearingSetup</code> is useful to reduce the amount of memory to be allocated,  if function <a href="EquationReduction.html#ModiaBase.tearEquations!"><code>tearEquations!</code></a> shall be called several times on equation systems from <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/Tearing.jl#L43-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModiaBase.tearEquations!" href="#ModiaBase.tearEquations!"><code>ModiaBase.tearEquations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(eSolved, vSolved, eResidue, vTear) = tearEquations!(GorTs, isSolvable, es, vs; 
    eSolvedFixed=Int[], vSolvedFixed=Int[], check=true)</code></pre><p>This function tears a system of equations consisting of equations <code>es</code> and <code>eSolvedFixed</code> that are functions of variables <code>vs</code> and <code>vSolvedFixed</code>. The optional arguments <code>eSolvedFixed, vSolvedFixed</code>  define the starting Directed Acyclic Graph (solving equations eSolvedFixed[1] for variable vSolvedFixed[1], eSolvedFixed[2] for variable vSolvedFixed[2] etc.) starting at <code>vSolvedFixed[1]</code>.</p><p>The function returns the teared equations so that if <code>vTear</code> are given, <code>vSolved</code> can be computed from <code>eSolved</code> in a forward sequence (so solving <code>eSolved[1]</code> for <code>vSolved[1]</code>, <code>eSolved[2]</code> for <code>vSolved[2]</code>, and so on). <code>vTear</code> must be selected, so that the equations <code>eResidues</code> are fulfilled. Equations <code>eSolved</code> and <code>eResidue</code> are the (reordered) union of <code>es</code> and <code>eSolvedFixed</code>. Variables vSolved<code>and</code>vTear<code>are the (reordered) union of</code>vs<code>and</code>vSolvedFixed`.</p><p>This means that an algebraic equation system <code>0 = g(w)</code>  (<code>g</code> are equations <code>es</code> and <code>eSolvedFixed</code>;  <code>w</code> are unknowns <code>vs</code> and <code>vSolvedFixed</code>) is solved as  much as possible explicitly for the unknowns resulting in</p><pre><code class="nohighlight hljs">w_e := g_e(w_t)
  0  = g_r(w_t, w_e)</code></pre><p>where </p><ul><li><code>w</code> (= vs and vSolvedFixed) consists of all elements of <code>w_e, w_t</code>;</li><li>equations <code>g_e</code> of <code>g</code> are explicitly solved for <code>w_e</code>;</li><li>equations <code>g_r</code> are the equations of <code>g</code> that cannot be explicitly solved (= residual equations).</li></ul><p><strong>Required arguments</strong></p><ul><li><p><code>GorTs</code>: Either a bi-partite graph <code>G::Vector{Vector{Int}}</code> or <code>ts::TearingSetup</code>          generated with constructor <code>ts = TearingSetup(G)</code>.                  <code>ts</code> is re-initialized in <code>tearEquations!</code> for any call of the function.          <code>TearingSetup</code> is useful to reduce the amount of memory to be allocated,           if several equation systems shall be teared from <code>G</code>.</p></li><li><p><code>isSolvable(e,v)</code>: Function that returns true, if equation <code>e</code>          can be solved for variable <code>v</code> without influencing the solution space          (= rank preserving operation).</p></li><li><p><code>es::Vector{Int}</code>: Vector of equations that shall be solved with respect to variables <code>vs</code>.          <code>es</code> must be equations from <code>G</code>.</p></li><li><p><code>vs</code>: Either of type <code>Vector{Int}</code> or of type <code>Vector{Vector{Int}}</code>.           <code>vs</code> are the unknown variables that shall be solved from <code>es</code>.           If <code>vs::Vector{Vector{Int}}</code>, it is first tried to solve <code>es</code>           for <code>vs[1]</code>, then for <code>vs[2]</code> etc.           (so <code>vs</code> defines a priority to solve for variables).            </p></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>eSolvedFixed::Vector{Int}</code>: Equations of <code>G</code> that are already defined to be solved for <code>vSolvedFixed</code>.</li><li><code>vSolvedFixed::Vector{Int]</code>: Variables of <code>G</code> that are explicitly solved from <code>eSolvedFixed</code>.</li><li><code>check::Bool</code>: = true, if various checks shall be performed, for example           that eSolvedFixed/vSolvedFixed and eSolved/vSolved are a DAG respectively.</li></ul><p><strong>Return arguments</strong></p><ul><li><code>eSolved::Vector{Int}</code>: Equations that are explicitly solved in the order <code>eSolved[1], eSolved[2], ...</code>.</li><li><code>vSolved::Vector{Int}</code>: Equation <code>eSolved[i]</code> is explicitly solved for variable <code>vSolved[i]</code>.</li><li><code>eResdiue::Vector{Int}</code>: Residual equations that are not explicitly solved.</li><li><code>vTear::Vector{Int}</code>: Tearing variables, so variables that are assumed to be known, when solving                       equations <code>eSolved</code>.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using ModiaBase

G = Vector{Int}[ [1,2,4],  # equation 1 depends on variables 1,2,4
                 [1,7],
                 [3,4],
                 [3,7],
                 [6,7],
                 [2] ]
    
es = [3,4,2,1]    # Solve equations 3,4,2,1                 
vs = [3,7,1,4]    # for variables 3,7,1,4 
isSolvable(e,v) = true  # Assume that every equation is solvable for its unknowns 
 
(eSolved,vSolved,eResidue,vTear) = tearEquations!(G, isSolvable, es, vs)

# eSolved  = [3,4,2]
# vSolved  = [3,7,1]
# eResidue = [1]
# vTear    = [4]</code></pre><p><strong>Algorithm</strong></p><p>The algorithm used in this function is sketched in the paper:</p><ul><li>Otter, Elmqvist (2017): <a href="http://www.ep.liu.se/ecp/132/064/ecp17132565.pdf">Transformation of Differential Algebraic Array Equations to Index One Form</a>.  Modelica&#39;2017 Conference.</li></ul><p>The function uses several extensions of the described basic tearing algorithm that are important for transforming higher index Differential Algebraic Equations to index one form. Note, the traversals in Directed-Acyclic-Graphs - the core operation of the tearing algorithm - is <strong>not</strong> performed with recursive function calls but with  while loops and an explicit stack, in order to avoid function stack overflow for large algebraic loops. Tests up to 1 million equations in 1 million unknowns have been performed.</p><p>For improving efficiency, algorithm N of the following paper is used as utility algorithm:</p><ul><li>Bender, Fineman, Gilbert, Tarjan (2016):  <a href="http://dl.acm.org/citation.cfm?id=2756553">A New Approach to Incremental Cycle Detection and Related Problems</a>. ACM Transactions on Algorithms, Volume 12, Issue 2, Feb.</li></ul><p><strong>Main developer</strong></p><p><a href="https://rmc.dlr.de/sr/en/staff/martin.otter/">Martin Otter</a>,  <a href="https://www.dlr.de/sr/en">DLR - Institute of System Dynamics and Control</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/ModiaBase.jl/blob/0de87d4419c3a906234d02558a20a5137f8b017f/src/Tearing.jl#L427-L548">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="EquationSorting.html">« Equation Sorting</a><a class="docs-footer-nextpage" href="TransformationToODEs.html">Transformation to ODE System »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Sunday 20 February 2022 22:20">Sunday 20 February 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
